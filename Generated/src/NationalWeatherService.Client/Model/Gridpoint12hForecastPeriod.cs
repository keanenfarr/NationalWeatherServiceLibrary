// <auto-generated>
/*
 * weather.gov API
 *
 * weather.gov API
 *
 * The version of the OpenAPI document: 2.6.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using NationalWeatherService.Client.Client;

namespace NationalWeatherService.Client.Model
{
    /// <summary>
    /// An object containing forecast information for a specific time period (generally 12-hour or 1-hour). 
    /// </summary>
    public partial class Gridpoint12hForecastPeriod : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Gridpoint12hForecastPeriod" /> class.
        /// </summary>
        /// <param name="number">Sequential period number.</param>
        /// <param name="name">A textual identifier for the period. This value will not be present for hourly forecasts. </param>
        /// <param name="startTime">The starting time that this forecast period is valid for.</param>
        /// <param name="endTime">The ending time that this forecast period is valid for.</param>
        /// <param name="isDaytime">Indicates whether this period is daytime or nighttime.</param>
        /// <param name="temperature">temperature</param>
        /// <param name="temperatureUnit">The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \&quot;forecast_temperature_qv\&quot; feature flag on the request. </param>
        /// <param name="temperatureTrend">If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day) </param>
        /// <param name="probabilityOfPrecipitation">probabilityOfPrecipitation</param>
        /// <param name="windSpeed">windSpeed</param>
        /// <param name="windGust">windGust</param>
        /// <param name="windDirection">The prevailing direction of the wind for the period, using a 16-point compass.</param>
        /// <param name="icon">A link to an icon representing the forecast summary.</param>
        /// <param name="shortForecast">A brief textual forecast summary for the period.</param>
        /// <param name="detailedForecast">A detailed textual forecast for the period.</param>
        [JsonConstructor]
        public Gridpoint12hForecastPeriod(Option<int?> number = default, Option<string?> name = default, Option<DateTime?> startTime = default, Option<DateTime?> endTime = default, Option<bool?> isDaytime = default, Option<GridpointHourlyForecastPeriodTemperature?> temperature = default, Option<TemperatureUnitEnum?> temperatureUnit = default, Option<TemperatureTrendEnum?> temperatureTrend = default, Option<QuantitativeValue?> probabilityOfPrecipitation = default, Option<GridpointHourlyForecastPeriodWindSpeed?> windSpeed = default, Option<GridpointHourlyForecastPeriodWindGust?> windGust = default, Option<WindDirectionEnum?> windDirection = default, Option<string?> icon = default, Option<string?> shortForecast = default, Option<string?> detailedForecast = default)
        {
            NumberOption = number;
            NameOption = name;
            StartTimeOption = startTime;
            EndTimeOption = endTime;
            IsDaytimeOption = isDaytime;
            TemperatureOption = temperature;
            TemperatureUnitOption = temperatureUnit;
            TemperatureTrendOption = temperatureTrend;
            ProbabilityOfPrecipitationOption = probabilityOfPrecipitation;
            WindSpeedOption = windSpeed;
            WindGustOption = windGust;
            WindDirectionOption = windDirection;
            IconOption = icon;
            ShortForecastOption = shortForecast;
            DetailedForecastOption = detailedForecast;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \&quot;forecast_temperature_qv\&quot; feature flag on the request. 
        /// </summary>
        /// <value>The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \&quot;forecast_temperature_qv\&quot; feature flag on the request. </value>
        public enum TemperatureUnitEnum
        {
            /// <summary>
            /// Enum F for value: F
            /// </summary>
            F = 1,

            /// <summary>
            /// Enum C for value: C
            /// </summary>
            C = 2
        }

        /// <summary>
        /// Returns a <see cref="TemperatureUnitEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TemperatureUnitEnum TemperatureUnitEnumFromString(string value)
        {
            if (value.Equals("F"))
                return TemperatureUnitEnum.F;

            if (value.Equals("C"))
                return TemperatureUnitEnum.C;

            throw new NotImplementedException($"Could not convert value to type TemperatureUnitEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TemperatureUnitEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TemperatureUnitEnum? TemperatureUnitEnumFromStringOrDefault(string value)
        {
            if (value.Equals("F"))
                return TemperatureUnitEnum.F;

            if (value.Equals("C"))
                return TemperatureUnitEnum.C;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TemperatureUnitEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string TemperatureUnitEnumToJsonValue(TemperatureUnitEnum? value)
        {
            if (value == TemperatureUnitEnum.F)
                return "F";

            if (value == TemperatureUnitEnum.C)
                return "C";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of TemperatureUnit
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TemperatureUnitEnum?> TemperatureUnitOption { get; private set; }

        /// <summary>
        /// The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \&quot;forecast_temperature_qv\&quot; feature flag on the request. 
        /// </summary>
        /// <value>The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \&quot;forecast_temperature_qv\&quot; feature flag on the request. </value>
        [JsonPropertyName("temperatureUnit")]
        [Obsolete]
        public TemperatureUnitEnum? TemperatureUnit { get { return this.TemperatureUnitOption; } set { this.TemperatureUnitOption = new(value); } }

        /// <summary>
        /// If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day) 
        /// </summary>
        /// <value>If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day) </value>
        public enum TemperatureTrendEnum
        {
            /// <summary>
            /// Enum Rising for value: rising
            /// </summary>
            Rising = 1,

            /// <summary>
            /// Enum Falling for value: falling
            /// </summary>
            Falling = 2
        }

        /// <summary>
        /// Returns a <see cref="TemperatureTrendEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TemperatureTrendEnum TemperatureTrendEnumFromString(string value)
        {
            if (value.Equals("rising"))
                return TemperatureTrendEnum.Rising;

            if (value.Equals("falling"))
                return TemperatureTrendEnum.Falling;

            throw new NotImplementedException($"Could not convert value to type TemperatureTrendEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TemperatureTrendEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TemperatureTrendEnum? TemperatureTrendEnumFromStringOrDefault(string value)
        {
            if (value.Equals("rising"))
                return TemperatureTrendEnum.Rising;

            if (value.Equals("falling"))
                return TemperatureTrendEnum.Falling;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TemperatureTrendEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string? TemperatureTrendEnumToJsonValue(TemperatureTrendEnum? value)
        {
            if (value == null)
                return null;

            if (value == TemperatureTrendEnum.Rising)
                return "rising";

            if (value == TemperatureTrendEnum.Falling)
                return "falling";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of TemperatureTrend
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TemperatureTrendEnum?> TemperatureTrendOption { get; private set; }

        /// <summary>
        /// If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day) 
        /// </summary>
        /// <value>If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day) </value>
        [JsonPropertyName("temperatureTrend")]
        public TemperatureTrendEnum? TemperatureTrend { get { return this.TemperatureTrendOption; } set { this.TemperatureTrendOption = new(value); } }

        /// <summary>
        /// The prevailing direction of the wind for the period, using a 16-point compass.
        /// </summary>
        /// <value>The prevailing direction of the wind for the period, using a 16-point compass.</value>
        public enum WindDirectionEnum
        {
            /// <summary>
            /// Enum N for value: N
            /// </summary>
            N = 1,

            /// <summary>
            /// Enum NNE for value: NNE
            /// </summary>
            NNE = 2,

            /// <summary>
            /// Enum NE for value: NE
            /// </summary>
            NE = 3,

            /// <summary>
            /// Enum ENE for value: ENE
            /// </summary>
            ENE = 4,

            /// <summary>
            /// Enum E for value: E
            /// </summary>
            E = 5,

            /// <summary>
            /// Enum ESE for value: ESE
            /// </summary>
            ESE = 6,

            /// <summary>
            /// Enum SE for value: SE
            /// </summary>
            SE = 7,

            /// <summary>
            /// Enum SSE for value: SSE
            /// </summary>
            SSE = 8,

            /// <summary>
            /// Enum S for value: S
            /// </summary>
            S = 9,

            /// <summary>
            /// Enum SSW for value: SSW
            /// </summary>
            SSW = 10,

            /// <summary>
            /// Enum SW for value: SW
            /// </summary>
            SW = 11,

            /// <summary>
            /// Enum WSW for value: WSW
            /// </summary>
            WSW = 12,

            /// <summary>
            /// Enum W for value: W
            /// </summary>
            W = 13,

            /// <summary>
            /// Enum WNW for value: WNW
            /// </summary>
            WNW = 14,

            /// <summary>
            /// Enum NW for value: NW
            /// </summary>
            NW = 15,

            /// <summary>
            /// Enum NNW for value: NNW
            /// </summary>
            NNW = 16
        }

        /// <summary>
        /// Returns a <see cref="WindDirectionEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static WindDirectionEnum WindDirectionEnumFromString(string value)
        {
            if (value.Equals("N"))
                return WindDirectionEnum.N;

            if (value.Equals("NNE"))
                return WindDirectionEnum.NNE;

            if (value.Equals("NE"))
                return WindDirectionEnum.NE;

            if (value.Equals("ENE"))
                return WindDirectionEnum.ENE;

            if (value.Equals("E"))
                return WindDirectionEnum.E;

            if (value.Equals("ESE"))
                return WindDirectionEnum.ESE;

            if (value.Equals("SE"))
                return WindDirectionEnum.SE;

            if (value.Equals("SSE"))
                return WindDirectionEnum.SSE;

            if (value.Equals("S"))
                return WindDirectionEnum.S;

            if (value.Equals("SSW"))
                return WindDirectionEnum.SSW;

            if (value.Equals("SW"))
                return WindDirectionEnum.SW;

            if (value.Equals("WSW"))
                return WindDirectionEnum.WSW;

            if (value.Equals("W"))
                return WindDirectionEnum.W;

            if (value.Equals("WNW"))
                return WindDirectionEnum.WNW;

            if (value.Equals("NW"))
                return WindDirectionEnum.NW;

            if (value.Equals("NNW"))
                return WindDirectionEnum.NNW;

            throw new NotImplementedException($"Could not convert value to type WindDirectionEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="WindDirectionEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static WindDirectionEnum? WindDirectionEnumFromStringOrDefault(string value)
        {
            if (value.Equals("N"))
                return WindDirectionEnum.N;

            if (value.Equals("NNE"))
                return WindDirectionEnum.NNE;

            if (value.Equals("NE"))
                return WindDirectionEnum.NE;

            if (value.Equals("ENE"))
                return WindDirectionEnum.ENE;

            if (value.Equals("E"))
                return WindDirectionEnum.E;

            if (value.Equals("ESE"))
                return WindDirectionEnum.ESE;

            if (value.Equals("SE"))
                return WindDirectionEnum.SE;

            if (value.Equals("SSE"))
                return WindDirectionEnum.SSE;

            if (value.Equals("S"))
                return WindDirectionEnum.S;

            if (value.Equals("SSW"))
                return WindDirectionEnum.SSW;

            if (value.Equals("SW"))
                return WindDirectionEnum.SW;

            if (value.Equals("WSW"))
                return WindDirectionEnum.WSW;

            if (value.Equals("W"))
                return WindDirectionEnum.W;

            if (value.Equals("WNW"))
                return WindDirectionEnum.WNW;

            if (value.Equals("NW"))
                return WindDirectionEnum.NW;

            if (value.Equals("NNW"))
                return WindDirectionEnum.NNW;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="WindDirectionEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string WindDirectionEnumToJsonValue(WindDirectionEnum? value)
        {
            if (value == WindDirectionEnum.N)
                return "N";

            if (value == WindDirectionEnum.NNE)
                return "NNE";

            if (value == WindDirectionEnum.NE)
                return "NE";

            if (value == WindDirectionEnum.ENE)
                return "ENE";

            if (value == WindDirectionEnum.E)
                return "E";

            if (value == WindDirectionEnum.ESE)
                return "ESE";

            if (value == WindDirectionEnum.SE)
                return "SE";

            if (value == WindDirectionEnum.SSE)
                return "SSE";

            if (value == WindDirectionEnum.S)
                return "S";

            if (value == WindDirectionEnum.SSW)
                return "SSW";

            if (value == WindDirectionEnum.SW)
                return "SW";

            if (value == WindDirectionEnum.WSW)
                return "WSW";

            if (value == WindDirectionEnum.W)
                return "W";

            if (value == WindDirectionEnum.WNW)
                return "WNW";

            if (value == WindDirectionEnum.NW)
                return "NW";

            if (value == WindDirectionEnum.NNW)
                return "NNW";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of WindDirection
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WindDirectionEnum?> WindDirectionOption { get; private set; }

        /// <summary>
        /// The prevailing direction of the wind for the period, using a 16-point compass.
        /// </summary>
        /// <value>The prevailing direction of the wind for the period, using a 16-point compass.</value>
        [JsonPropertyName("windDirection")]
        public WindDirectionEnum? WindDirection { get { return this.WindDirectionOption; } set { this.WindDirectionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Number
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> NumberOption { get; private set; }

        /// <summary>
        /// Sequential period number.
        /// </summary>
        /// <value>Sequential period number.</value>
        [JsonPropertyName("number")]
        public int? Number { get { return this.NumberOption; } set { this.NumberOption = new(value); } }

        /// <summary>
        /// Used to track the state of Name
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> NameOption { get; private set; }

        /// <summary>
        /// A textual identifier for the period. This value will not be present for hourly forecasts. 
        /// </summary>
        /// <value>A textual identifier for the period. This value will not be present for hourly forecasts. </value>
        /* <example>Tuesday Night</example> */
        [JsonPropertyName("name")]
        public string? Name { get { return this.NameOption; } set { this.NameOption = new(value); } }

        /// <summary>
        /// Used to track the state of StartTime
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> StartTimeOption { get; private set; }

        /// <summary>
        /// The starting time that this forecast period is valid for.
        /// </summary>
        /// <value>The starting time that this forecast period is valid for.</value>
        [JsonPropertyName("startTime")]
        public DateTime? StartTime { get { return this.StartTimeOption; } set { this.StartTimeOption = new(value); } }

        /// <summary>
        /// Used to track the state of EndTime
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> EndTimeOption { get; private set; }

        /// <summary>
        /// The ending time that this forecast period is valid for.
        /// </summary>
        /// <value>The ending time that this forecast period is valid for.</value>
        [JsonPropertyName("endTime")]
        public DateTime? EndTime { get { return this.EndTimeOption; } set { this.EndTimeOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsDaytime
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsDaytimeOption { get; private set; }

        /// <summary>
        /// Indicates whether this period is daytime or nighttime.
        /// </summary>
        /// <value>Indicates whether this period is daytime or nighttime.</value>
        [JsonPropertyName("isDaytime")]
        public bool? IsDaytime { get { return this.IsDaytimeOption; } set { this.IsDaytimeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Temperature
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<GridpointHourlyForecastPeriodTemperature?> TemperatureOption { get; private set; }

        /// <summary>
        /// Gets or Sets Temperature
        /// </summary>
        [JsonPropertyName("temperature")]
        public GridpointHourlyForecastPeriodTemperature? Temperature { get { return this.TemperatureOption; } set { this.TemperatureOption = new(value); } }

        /// <summary>
        /// Used to track the state of ProbabilityOfPrecipitation
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<QuantitativeValue?> ProbabilityOfPrecipitationOption { get; private set; }

        /// <summary>
        /// Gets or Sets ProbabilityOfPrecipitation
        /// </summary>
        [JsonPropertyName("probabilityOfPrecipitation")]
        public QuantitativeValue? ProbabilityOfPrecipitation { get { return this.ProbabilityOfPrecipitationOption; } set { this.ProbabilityOfPrecipitationOption = new(value); } }

        /// <summary>
        /// Used to track the state of WindSpeed
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<GridpointHourlyForecastPeriodWindSpeed?> WindSpeedOption { get; private set; }

        /// <summary>
        /// Gets or Sets WindSpeed
        /// </summary>
        [JsonPropertyName("windSpeed")]
        public GridpointHourlyForecastPeriodWindSpeed? WindSpeed { get { return this.WindSpeedOption; } set { this.WindSpeedOption = new(value); } }

        /// <summary>
        /// Used to track the state of WindGust
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<GridpointHourlyForecastPeriodWindGust?> WindGustOption { get; private set; }

        /// <summary>
        /// Gets or Sets WindGust
        /// </summary>
        [JsonPropertyName("windGust")]
        public GridpointHourlyForecastPeriodWindGust? WindGust { get { return this.WindGustOption; } set { this.WindGustOption = new(value); } }

        /// <summary>
        /// Used to track the state of Icon
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IconOption { get; private set; }

        /// <summary>
        /// A link to an icon representing the forecast summary.
        /// </summary>
        /// <value>A link to an icon representing the forecast summary.</value>
        [JsonPropertyName("icon")]
        [Obsolete]
        public string? Icon { get { return this.IconOption; } set { this.IconOption = new(value); } }

        /// <summary>
        /// Used to track the state of ShortForecast
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ShortForecastOption { get; private set; }

        /// <summary>
        /// A brief textual forecast summary for the period.
        /// </summary>
        /// <value>A brief textual forecast summary for the period.</value>
        [JsonPropertyName("shortForecast")]
        public string? ShortForecast { get { return this.ShortForecastOption; } set { this.ShortForecastOption = new(value); } }

        /// <summary>
        /// Used to track the state of DetailedForecast
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DetailedForecastOption { get; private set; }

        /// <summary>
        /// A detailed textual forecast for the period.
        /// </summary>
        /// <value>A detailed textual forecast for the period.</value>
        [JsonPropertyName("detailedForecast")]
        public string? DetailedForecast { get { return this.DetailedForecastOption; } set { this.DetailedForecastOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Gridpoint12hForecastPeriod {\n");
            sb.Append("  Number: ").Append(Number).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  EndTime: ").Append(EndTime).Append("\n");
            sb.Append("  IsDaytime: ").Append(IsDaytime).Append("\n");
            sb.Append("  Temperature: ").Append(Temperature).Append("\n");
            sb.Append("  TemperatureUnit: ").Append(TemperatureUnit).Append("\n");
            sb.Append("  TemperatureTrend: ").Append(TemperatureTrend).Append("\n");
            sb.Append("  ProbabilityOfPrecipitation: ").Append(ProbabilityOfPrecipitation).Append("\n");
            sb.Append("  WindSpeed: ").Append(WindSpeed).Append("\n");
            sb.Append("  WindGust: ").Append(WindGust).Append("\n");
            sb.Append("  WindDirection: ").Append(WindDirection).Append("\n");
            sb.Append("  Icon: ").Append(Icon).Append("\n");
            sb.Append("  ShortForecast: ").Append(ShortForecast).Append("\n");
            sb.Append("  DetailedForecast: ").Append(DetailedForecast).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Number (int) minimum
            if (this.NumberOption.IsSet && this.NumberOption.Value < (int)1)
            {
                yield return new ValidationResult("Invalid value for Number, must be a value greater than or equal to 1.", new [] { "Number" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Gridpoint12hForecastPeriod" />
    /// </summary>
    public class Gridpoint12hForecastPeriodJsonConverter : JsonConverter<Gridpoint12hForecastPeriod>
    {
        /// <summary>
        /// The format to use to serialize StartTime
        /// </summary>
        public static string StartTimeFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize EndTime
        /// </summary>
        public static string EndTimeFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Gridpoint12hForecastPeriod" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Gridpoint12hForecastPeriod Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<int?> number = default;
            Option<string?> name = default;
            Option<DateTime?> startTime = default;
            Option<DateTime?> endTime = default;
            Option<bool?> isDaytime = default;
            Option<GridpointHourlyForecastPeriodTemperature?> temperature = default;
            Option<Gridpoint12hForecastPeriod.TemperatureUnitEnum?> temperatureUnit = default;
            Option<Gridpoint12hForecastPeriod.TemperatureTrendEnum?> temperatureTrend = default;
            Option<QuantitativeValue?> probabilityOfPrecipitation = default;
            Option<GridpointHourlyForecastPeriodWindSpeed?> windSpeed = default;
            Option<GridpointHourlyForecastPeriodWindGust?> windGust = default;
            Option<Gridpoint12hForecastPeriod.WindDirectionEnum?> windDirection = default;
            Option<string?> icon = default;
            Option<string?> shortForecast = default;
            Option<string?> detailedForecast = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "number":
                            number = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "startTime":
                            startTime = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "endTime":
                            endTime = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "isDaytime":
                            isDaytime = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "temperature":
                            temperature = new Option<GridpointHourlyForecastPeriodTemperature?>(JsonSerializer.Deserialize<GridpointHourlyForecastPeriodTemperature>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "temperatureUnit":
                            string? temperatureUnitRawValue = utf8JsonReader.GetString();
                            if (temperatureUnitRawValue != null)
                                temperatureUnit = new Option<Gridpoint12hForecastPeriod.TemperatureUnitEnum?>(Gridpoint12hForecastPeriod.TemperatureUnitEnumFromStringOrDefault(temperatureUnitRawValue));
                            break;
                        case "temperatureTrend":
                            string? temperatureTrendRawValue = utf8JsonReader.GetString();
                            if (temperatureTrendRawValue != null)
                                temperatureTrend = new Option<Gridpoint12hForecastPeriod.TemperatureTrendEnum?>(Gridpoint12hForecastPeriod.TemperatureTrendEnumFromStringOrDefault(temperatureTrendRawValue));
                            break;
                        case "probabilityOfPrecipitation":
                            probabilityOfPrecipitation = new Option<QuantitativeValue?>(JsonSerializer.Deserialize<QuantitativeValue>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "windSpeed":
                            windSpeed = new Option<GridpointHourlyForecastPeriodWindSpeed?>(JsonSerializer.Deserialize<GridpointHourlyForecastPeriodWindSpeed>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "windGust":
                            windGust = new Option<GridpointHourlyForecastPeriodWindGust?>(JsonSerializer.Deserialize<GridpointHourlyForecastPeriodWindGust>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "windDirection":
                            string? windDirectionRawValue = utf8JsonReader.GetString();
                            if (windDirectionRawValue != null)
                                windDirection = new Option<Gridpoint12hForecastPeriod.WindDirectionEnum?>(Gridpoint12hForecastPeriod.WindDirectionEnumFromStringOrDefault(windDirectionRawValue));
                            break;
                        case "icon":
                            icon = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "shortForecast":
                            shortForecast = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "detailedForecast":
                            detailedForecast = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (number.IsSet && number.Value == null)
                throw new ArgumentNullException(nameof(number), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (startTime.IsSet && startTime.Value == null)
                throw new ArgumentNullException(nameof(startTime), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (endTime.IsSet && endTime.Value == null)
                throw new ArgumentNullException(nameof(endTime), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (isDaytime.IsSet && isDaytime.Value == null)
                throw new ArgumentNullException(nameof(isDaytime), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (temperature.IsSet && temperature.Value == null)
                throw new ArgumentNullException(nameof(temperature), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (temperatureUnit.IsSet && temperatureUnit.Value == null)
                throw new ArgumentNullException(nameof(temperatureUnit), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (probabilityOfPrecipitation.IsSet && probabilityOfPrecipitation.Value == null)
                throw new ArgumentNullException(nameof(probabilityOfPrecipitation), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (windSpeed.IsSet && windSpeed.Value == null)
                throw new ArgumentNullException(nameof(windSpeed), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (windDirection.IsSet && windDirection.Value == null)
                throw new ArgumentNullException(nameof(windDirection), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (icon.IsSet && icon.Value == null)
                throw new ArgumentNullException(nameof(icon), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (shortForecast.IsSet && shortForecast.Value == null)
                throw new ArgumentNullException(nameof(shortForecast), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            if (detailedForecast.IsSet && detailedForecast.Value == null)
                throw new ArgumentNullException(nameof(detailedForecast), "Property is not nullable for class Gridpoint12hForecastPeriod.");

            return new Gridpoint12hForecastPeriod(number, name, startTime, endTime, isDaytime, temperature, temperatureUnit, temperatureTrend, probabilityOfPrecipitation, windSpeed, windGust, windDirection, icon, shortForecast, detailedForecast);
        }

        /// <summary>
        /// Serializes a <see cref="Gridpoint12hForecastPeriod" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="gridpoint12hForecastPeriod"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Gridpoint12hForecastPeriod gridpoint12hForecastPeriod, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, gridpoint12hForecastPeriod, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Gridpoint12hForecastPeriod" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="gridpoint12hForecastPeriod"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Gridpoint12hForecastPeriod gridpoint12hForecastPeriod, JsonSerializerOptions jsonSerializerOptions)
        {
            if (gridpoint12hForecastPeriod.NameOption.IsSet && gridpoint12hForecastPeriod.Name == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.Name), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.TemperatureOption.IsSet && gridpoint12hForecastPeriod.Temperature == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.Temperature), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.ProbabilityOfPrecipitationOption.IsSet && gridpoint12hForecastPeriod.ProbabilityOfPrecipitation == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.ProbabilityOfPrecipitation), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.WindSpeedOption.IsSet && gridpoint12hForecastPeriod.WindSpeed == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.WindSpeed), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.IconOption.IsSet && gridpoint12hForecastPeriod.Icon == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.Icon), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.ShortForecastOption.IsSet && gridpoint12hForecastPeriod.ShortForecast == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.ShortForecast), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.DetailedForecastOption.IsSet && gridpoint12hForecastPeriod.DetailedForecast == null)
                throw new ArgumentNullException(nameof(gridpoint12hForecastPeriod.DetailedForecast), "Property is required for class Gridpoint12hForecastPeriod.");

            if (gridpoint12hForecastPeriod.NumberOption.IsSet)
                writer.WriteNumber("number", gridpoint12hForecastPeriod.NumberOption.Value!.Value);

            if (gridpoint12hForecastPeriod.NameOption.IsSet)
                writer.WriteString("name", gridpoint12hForecastPeriod.Name);

            if (gridpoint12hForecastPeriod.StartTimeOption.IsSet)
                writer.WriteString("startTime", gridpoint12hForecastPeriod.StartTimeOption.Value!.Value.ToString(StartTimeFormat));

            if (gridpoint12hForecastPeriod.EndTimeOption.IsSet)
                writer.WriteString("endTime", gridpoint12hForecastPeriod.EndTimeOption.Value!.Value.ToString(EndTimeFormat));

            if (gridpoint12hForecastPeriod.IsDaytimeOption.IsSet)
                writer.WriteBoolean("isDaytime", gridpoint12hForecastPeriod.IsDaytimeOption.Value!.Value);

            if (gridpoint12hForecastPeriod.TemperatureOption.IsSet)
            {
                writer.WritePropertyName("temperature");
                JsonSerializer.Serialize(writer, gridpoint12hForecastPeriod.Temperature, jsonSerializerOptions);
            }
            var temperatureUnitRawValue = Gridpoint12hForecastPeriod.TemperatureUnitEnumToJsonValue(gridpoint12hForecastPeriod.TemperatureUnitOption.Value!.Value);
            writer.WriteString("temperatureUnit", temperatureUnitRawValue);
            var temperatureTrendRawValue = Gridpoint12hForecastPeriod.TemperatureTrendEnumToJsonValue(gridpoint12hForecastPeriod.TemperatureTrendOption.Value!.Value);
            if (temperatureTrendRawValue != null)
                writer.WriteString("temperatureTrend", temperatureTrendRawValue);
            else
                writer.WriteNull("temperatureTrend");

            if (gridpoint12hForecastPeriod.ProbabilityOfPrecipitationOption.IsSet)
            {
                writer.WritePropertyName("probabilityOfPrecipitation");
                JsonSerializer.Serialize(writer, gridpoint12hForecastPeriod.ProbabilityOfPrecipitation, jsonSerializerOptions);
            }
            if (gridpoint12hForecastPeriod.WindSpeedOption.IsSet)
            {
                writer.WritePropertyName("windSpeed");
                JsonSerializer.Serialize(writer, gridpoint12hForecastPeriod.WindSpeed, jsonSerializerOptions);
            }
            if (gridpoint12hForecastPeriod.WindGustOption.IsSet)
                if (gridpoint12hForecastPeriod.WindGustOption.Value != null)
                {
                    writer.WritePropertyName("windGust");
                    JsonSerializer.Serialize(writer, gridpoint12hForecastPeriod.WindGust, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("windGust");
            var windDirectionRawValue = Gridpoint12hForecastPeriod.WindDirectionEnumToJsonValue(gridpoint12hForecastPeriod.WindDirectionOption.Value!.Value);
            writer.WriteString("windDirection", windDirectionRawValue);
            if (gridpoint12hForecastPeriod.IconOption.IsSet)
                writer.WriteString("icon", gridpoint12hForecastPeriod.Icon);

            if (gridpoint12hForecastPeriod.ShortForecastOption.IsSet)
                writer.WriteString("shortForecast", gridpoint12hForecastPeriod.ShortForecast);

            if (gridpoint12hForecastPeriod.DetailedForecastOption.IsSet)
                writer.WriteString("detailedForecast", gridpoint12hForecastPeriod.DetailedForecast);
        }
    }
}
