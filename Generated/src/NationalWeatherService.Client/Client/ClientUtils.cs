/*
 * weather.gov API
 *
 * weather.gov API
 *
 * The version of the OpenAPI document: 2.6.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.IO;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using NationalWeatherService.Client.Model;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("NationalWeatherService.Client.Test")]

namespace NationalWeatherService.Client.Client
{
    /// <summary>
    /// Utility functions providing some benefit to API client consumers.
    /// </summary>
    public static partial class ClientUtils
    {

        /// <summary>
        /// A delegate for events.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /// <returns></returns>
        public delegate void EventHandler<T>(object sender, T e) where T : EventArgs;

        /// <summary>
        /// An enum of headers
        /// </summary>
        public enum ApiKeyHeader
        {
            /// <summary>
            /// The User-Agent header
            /// </summary>
            User_Agent
        }

        /// <summary>
        /// Converte an ApiKeyHeader to a string
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="System.ComponentModel.InvalidEnumArgumentException"></exception>
        public static string ApiKeyHeaderToString(ApiKeyHeader value)
        {
            return value switch
            {
                ApiKeyHeader.User_Agent => "User-Agent",
                _ => throw new System.ComponentModel.InvalidEnumArgumentException(nameof(value), (int)value, typeof(ApiKeyHeader)),
            };
        }

        /// <summary>
        /// Returns true when deserialization succeeds.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="json"></param>
        /// <param name="options"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public static bool TryDeserialize<T>(string json, JsonSerializerOptions options, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result)
        {
            try
            {
                result = JsonSerializer.Deserialize<T>(json, options);
                return result != null;
            }
            catch (Exception)
            {
                result = default;
                return false;
            }
        }

        /// <summary>
        /// Returns true when deserialization succeeds.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="reader"></param>
        /// <param name="options"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public static bool TryDeserialize<T>(ref Utf8JsonReader reader, JsonSerializerOptions options, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result)
        {
            try
            {
                result = JsonSerializer.Deserialize<T>(ref reader, options);
                return result != null;
            }
            catch (Exception)
            {
                result = default;
                return false;
            }
        }

        /// <summary>
        /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
        /// If parameter is a list, join the list with ",".
        /// Otherwise just return the string.
        /// </summary>
        /// <param name="obj">The parameter (header, path, query, form).</param>
        /// <param name="format">The DateTime serialization format.</param>
        /// <returns>Formatted string.</returns>
        public static string? ParameterToString(object? obj, string? format = ISO8601_DATETIME_FORMAT)
        {
            if (obj is DateTime dateTime)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTime.ToString(format);
            if (obj is DateTimeOffset dateTimeOffset)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTimeOffset.ToString(format);
            if (obj is DateOnly dateOnly)
                return dateOnly.ToString(format);
            if (obj is bool boolean)
                return boolean
                    ? "true"
                    : "false";
            if (obj is Alert.CategoryEnum alertCategoryEnum)
                return Alert.CategoryEnumToJsonValue(alertCategoryEnum);
            if (obj is Alert.ResponseEnum alertResponseEnum)
                return Alert.ResponseEnumToJsonValue(alertResponseEnum);
            if (obj is Alert.ScopeEnum alertScopeEnum)
                return Alert.ScopeEnumToJsonValue(alertScopeEnum);
            if (obj is AlertCertainty alertCertainty)
                return AlertCertaintyValueConverter.ToJsonValue(alertCertainty);
            if (obj is AlertCollectionGeoJson.TypeEnum alertCollectionGeoJsonTypeEnum)
                return AlertCollectionGeoJson.TypeEnumToJsonValue(alertCollectionGeoJsonTypeEnum);
            if (obj is AlertGeoJson.TypeEnum alertGeoJsonTypeEnum)
                return AlertGeoJson.TypeEnumToJsonValue(alertGeoJsonTypeEnum);
            if (obj is AlertMessageType alertMessageType)
                return AlertMessageTypeValueConverter.ToJsonValue(alertMessageType);
            if (obj is AlertSeverity alertSeverity)
                return AlertSeverityValueConverter.ToJsonValue(alertSeverity);
            if (obj is AlertStatus alertStatus)
                return AlertStatusValueConverter.ToJsonValue(alertStatus);
            if (obj is AlertUrgency alertUrgency)
                return AlertUrgencyValueConverter.ToJsonValue(alertUrgency);
            if (obj is AreaCode areaCode)
                return AreaCodeValueConverter.ToJsonValue(areaCode);
            if (obj is CenterWeatherAdvisoryCollectionGeoJson.TypeEnum centerWeatherAdvisoryCollectionGeoJsonTypeEnum)
                return CenterWeatherAdvisoryCollectionGeoJson.TypeEnumToJsonValue(centerWeatherAdvisoryCollectionGeoJsonTypeEnum);
            if (obj is CenterWeatherAdvisoryGeoJson.TypeEnum centerWeatherAdvisoryGeoJsonTypeEnum)
                return CenterWeatherAdvisoryGeoJson.TypeEnumToJsonValue(centerWeatherAdvisoryGeoJsonTypeEnum);
            if (obj is GeoJSONLineString.TypeEnum geoJSONLineStringTypeEnum)
                return GeoJSONLineString.TypeEnumToJsonValue(geoJSONLineStringTypeEnum);
            if (obj is GeoJSONMultiLineString.TypeEnum geoJSONMultiLineStringTypeEnum)
                return GeoJSONMultiLineString.TypeEnumToJsonValue(geoJSONMultiLineStringTypeEnum);
            if (obj is GeoJSONMultiPoint.TypeEnum geoJSONMultiPointTypeEnum)
                return GeoJSONMultiPoint.TypeEnumToJsonValue(geoJSONMultiPointTypeEnum);
            if (obj is GeoJSONMultiPolygon.TypeEnum geoJSONMultiPolygonTypeEnum)
                return GeoJSONMultiPolygon.TypeEnumToJsonValue(geoJSONMultiPolygonTypeEnum);
            if (obj is GeoJSONPoint.TypeEnum geoJSONPointTypeEnum)
                return GeoJSONPoint.TypeEnumToJsonValue(geoJSONPointTypeEnum);
            if (obj is GeoJSONPolygon.TypeEnum geoJSONPolygonTypeEnum)
                return GeoJSONPolygon.TypeEnumToJsonValue(geoJSONPolygonTypeEnum);
            if (obj is GeoJsonFeature.TypeEnum geoJsonFeatureTypeEnum)
                return GeoJsonFeature.TypeEnumToJsonValue(geoJsonFeatureTypeEnum);
            if (obj is GeoJsonFeatureCollection.TypeEnum geoJsonFeatureCollectionTypeEnum)
                return GeoJsonFeatureCollection.TypeEnumToJsonValue(geoJsonFeatureCollectionTypeEnum);
            if (obj is Gridpoint.TypeEnum gridpointTypeEnum)
                return Gridpoint.TypeEnumToJsonValue(gridpointTypeEnum);
            if (obj is Gridpoint12hForecastGeoJson.TypeEnum gridpoint12hForecastGeoJsonTypeEnum)
                return Gridpoint12hForecastGeoJson.TypeEnumToJsonValue(gridpoint12hForecastGeoJsonTypeEnum);
            if (obj is Gridpoint12hForecastPeriod.TemperatureUnitEnum gridpoint12hForecastPeriodTemperatureUnitEnum)
                return Gridpoint12hForecastPeriod.TemperatureUnitEnumToJsonValue(gridpoint12hForecastPeriodTemperatureUnitEnum);
            if (obj is Gridpoint12hForecastPeriod.TemperatureTrendEnum gridpoint12hForecastPeriodTemperatureTrendEnum)
                return Gridpoint12hForecastPeriod.TemperatureTrendEnumToJsonValue(gridpoint12hForecastPeriodTemperatureTrendEnum);
            if (obj is Gridpoint12hForecastPeriod.WindDirectionEnum gridpoint12hForecastPeriodWindDirectionEnum)
                return Gridpoint12hForecastPeriod.WindDirectionEnumToJsonValue(gridpoint12hForecastPeriodWindDirectionEnum);
            if (obj is GridpointForecastUnits gridpointForecastUnits)
                return GridpointForecastUnitsValueConverter.ToJsonValue(gridpointForecastUnits);
            if (obj is GridpointGeoJson.TypeEnum gridpointGeoJsonTypeEnum)
                return GridpointGeoJson.TypeEnumToJsonValue(gridpointGeoJsonTypeEnum);
            if (obj is GridpointHourlyForecastGeoJson.TypeEnum gridpointHourlyForecastGeoJsonTypeEnum)
                return GridpointHourlyForecastGeoJson.TypeEnumToJsonValue(gridpointHourlyForecastGeoJsonTypeEnum);
            if (obj is GridpointHourlyForecastPeriod.TemperatureUnitEnum gridpointHourlyForecastPeriodTemperatureUnitEnum)
                return GridpointHourlyForecastPeriod.TemperatureUnitEnumToJsonValue(gridpointHourlyForecastPeriodTemperatureUnitEnum);
            if (obj is GridpointHourlyForecastPeriod.TemperatureTrendEnum gridpointHourlyForecastPeriodTemperatureTrendEnum)
                return GridpointHourlyForecastPeriod.TemperatureTrendEnumToJsonValue(gridpointHourlyForecastPeriodTemperatureTrendEnum);
            if (obj is GridpointHourlyForecastPeriod.WindDirectionEnum gridpointHourlyForecastPeriodWindDirectionEnum)
                return GridpointHourlyForecastPeriod.WindDirectionEnumToJsonValue(gridpointHourlyForecastPeriodWindDirectionEnum);
            if (obj is GridpointWeatherValuesInnerValueInner.AttributesEnum gridpointWeatherValuesInnerValueInnerAttributesEnum)
                return GridpointWeatherValuesInnerValueInner.AttributesEnumToJsonValue(gridpointWeatherValuesInnerValueInnerAttributesEnum);
            if (obj is GridpointWeatherValuesInnerValueInner.CoverageEnum gridpointWeatherValuesInnerValueInnerCoverageEnum)
                return GridpointWeatherValuesInnerValueInner.CoverageEnumToJsonValue(gridpointWeatherValuesInnerValueInnerCoverageEnum);
            if (obj is GridpointWeatherValuesInnerValueInner.WeatherEnum gridpointWeatherValuesInnerValueInnerWeatherEnum)
                return GridpointWeatherValuesInnerValueInner.WeatherEnumToJsonValue(gridpointWeatherValuesInnerValueInnerWeatherEnum);
            if (obj is GridpointWeatherValuesInnerValueInner.IntensityEnum gridpointWeatherValuesInnerValueInnerIntensityEnum)
                return GridpointWeatherValuesInnerValueInner.IntensityEnumToJsonValue(gridpointWeatherValuesInnerValueInnerIntensityEnum);
            if (obj is LandRegionCode landRegionCode)
                return LandRegionCodeValueConverter.ToJsonValue(landRegionCode);
            if (obj is MarineAreaCode marineAreaCode)
                return MarineAreaCodeValueConverter.ToJsonValue(marineAreaCode);
            if (obj is MarineRegionCode marineRegionCode)
                return MarineRegionCodeValueConverter.ToJsonValue(marineRegionCode);
            if (obj is MetarPhenomenon.WeatherEnum metarPhenomenonWeatherEnum)
                return MetarPhenomenon.WeatherEnumToJsonValue(metarPhenomenonWeatherEnum);
            if (obj is MetarPhenomenon.IntensityEnum metarPhenomenonIntensityEnum)
                return MetarPhenomenon.IntensityEnumToJsonValue(metarPhenomenonIntensityEnum);
            if (obj is MetarPhenomenon.ModifierEnum metarPhenomenonModifierEnum)
                return MetarPhenomenon.ModifierEnumToJsonValue(metarPhenomenonModifierEnum);
            if (obj is MetarSkyCoverage metarSkyCoverage)
                return MetarSkyCoverageValueConverter.ToJsonValue(metarSkyCoverage);
            if (obj is NWSCenterWeatherServiceUnitId nWSCenterWeatherServiceUnitId)
                return NWSCenterWeatherServiceUnitIdValueConverter.ToJsonValue(nWSCenterWeatherServiceUnitId);
            if (obj is NWSForecastOfficeId nWSForecastOfficeId)
                return NWSForecastOfficeIdValueConverter.ToJsonValue(nWSForecastOfficeId);
            if (obj is NWSNationalHQId nWSNationalHQId)
                return NWSNationalHQIdValueConverter.ToJsonValue(nWSNationalHQId);
            if (obj is NWSOfficeId nWSOfficeId)
                return NWSOfficeIdValueConverter.ToJsonValue(nWSOfficeId);
            if (obj is NWSRegionalHQId nWSRegionalHQId)
                return NWSRegionalHQIdValueConverter.ToJsonValue(nWSRegionalHQId);
            if (obj is NWSZoneType nWSZoneType)
                return NWSZoneTypeValueConverter.ToJsonValue(nWSZoneType);
            if (obj is Observation.TypeEnum observationTypeEnum)
                return Observation.TypeEnumToJsonValue(observationTypeEnum);
            if (obj is ObservationCollectionGeoJson.TypeEnum observationCollectionGeoJsonTypeEnum)
                return ObservationCollectionGeoJson.TypeEnumToJsonValue(observationCollectionGeoJsonTypeEnum);
            if (obj is ObservationGeoJson.TypeEnum observationGeoJsonTypeEnum)
                return ObservationGeoJson.TypeEnumToJsonValue(observationGeoJsonTypeEnum);
            if (obj is ObservationStation.TypeEnum observationStationTypeEnum)
                return ObservationStation.TypeEnumToJsonValue(observationStationTypeEnum);
            if (obj is ObservationStationCollectionGeoJson.TypeEnum observationStationCollectionGeoJsonTypeEnum)
                return ObservationStationCollectionGeoJson.TypeEnumToJsonValue(observationStationCollectionGeoJsonTypeEnum);
            if (obj is ObservationStationGeoJson.TypeEnum observationStationGeoJsonTypeEnum)
                return ObservationStationGeoJson.TypeEnumToJsonValue(observationStationGeoJsonTypeEnum);
            if (obj is ObservationStationJsonLd.TypeEnum observationStationJsonLdTypeEnum)
                return ObservationStationJsonLd.TypeEnumToJsonValue(observationStationJsonLdTypeEnum);
            if (obj is Office.TypeEnum officeTypeEnum)
                return Office.TypeEnumToJsonValue(officeTypeEnum);
            if (obj is OfficeAddress.TypeEnum officeAddressTypeEnum)
                return OfficeAddress.TypeEnumToJsonValue(officeAddressTypeEnum);
            if (obj is Point.TypeEnum pointTypeEnum)
                return Point.TypeEnumToJsonValue(pointTypeEnum);
            if (obj is PointGeoJson.TypeEnum pointGeoJsonTypeEnum)
                return PointGeoJson.TypeEnumToJsonValue(pointGeoJsonTypeEnum);
            if (obj is PointJsonLd.TypeEnum pointJsonLdTypeEnum)
                return PointJsonLd.TypeEnumToJsonValue(pointJsonLdTypeEnum);
            if (obj is QuantitativeValue.QualityControlEnum quantitativeValueQualityControlEnum)
                return QuantitativeValue.QualityControlEnumToJsonValue(quantitativeValueQualityControlEnum);
            if (obj is RegionCode regionCode)
                return RegionCodeValueConverter.ToJsonValue(regionCode);
            if (obj is RelativeLocationGeoJson.TypeEnum relativeLocationGeoJsonTypeEnum)
                return RelativeLocationGeoJson.TypeEnumToJsonValue(relativeLocationGeoJsonTypeEnum);
            if (obj is SigmetCollectionGeoJson.TypeEnum sigmetCollectionGeoJsonTypeEnum)
                return SigmetCollectionGeoJson.TypeEnumToJsonValue(sigmetCollectionGeoJsonTypeEnum);
            if (obj is SigmetGeoJson.TypeEnum sigmetGeoJsonTypeEnum)
                return SigmetGeoJson.TypeEnumToJsonValue(sigmetGeoJsonTypeEnum);
            if (obj is StateTerritoryCode stateTerritoryCode)
                return StateTerritoryCodeValueConverter.ToJsonValue(stateTerritoryCode);
            if (obj is Zone.TypeEnum zoneTypeEnum)
                return Zone.TypeEnumToJsonValue(zoneTypeEnum);
            if (obj is Zone.StateEnum zoneStateEnum)
                return Zone.StateEnumToJsonValue(zoneStateEnum);
            if (obj is ZoneCollectionGeoJson.TypeEnum zoneCollectionGeoJsonTypeEnum)
                return ZoneCollectionGeoJson.TypeEnumToJsonValue(zoneCollectionGeoJsonTypeEnum);
            if (obj is ZoneForecastGeoJson.TypeEnum zoneForecastGeoJsonTypeEnum)
                return ZoneForecastGeoJson.TypeEnumToJsonValue(zoneForecastGeoJsonTypeEnum);
            if (obj is ZoneGeoJson.TypeEnum zoneGeoJsonTypeEnum)
                return ZoneGeoJson.TypeEnumToJsonValue(zoneGeoJsonTypeEnum);
            if (obj is ICollection collection)
            {
                List<string?> entries = new();
                foreach (var entry in collection)
                    entries.Add(ParameterToString(entry));
                return string.Join(",", entries);
            }

            return Convert.ToString(obj, System.Globalization.CultureInfo.InvariantCulture);
        }

        /// <summary>
        /// URL encode a string
        /// Credit/Ref: https://github.com/restsharp/RestSharp/blob/master/RestSharp/Extensions/StringExtensions.cs#L50
        /// </summary>
        /// <param name="input">string to be URL encoded</param>
        /// <returns>Byte array</returns>
        public static string UrlEncode(string input)
        {
            const int maxLength = 32766;

            if (input == null)
            {
                throw new ArgumentNullException("input");
            }

            if (input.Length <= maxLength)
            {
                return Uri.EscapeDataString(input);
            }

            StringBuilder sb = new StringBuilder(input.Length * 2);
            int index = 0;

            while (index < input.Length)
            {
                int length = Math.Min(input.Length - index, maxLength);
                string subString = input.Substring(index, length);

                sb.Append(Uri.EscapeDataString(subString));
                index += subString.Length;
            }

            return sb.ToString();
        }

        /// <summary>
        /// Encode string in base64 format.
        /// </summary>
        /// <param name="text">string to be encoded.</param>
        /// <returns>Encoded string.</returns>
        public static string Base64Encode(string text)
        {
            return Convert.ToBase64String(global::System.Text.Encoding.UTF8.GetBytes(text));
        }

        /// <summary>
        /// Convert stream to byte array
        /// </summary>
        /// <param name="inputStream">Input stream to be converted</param>
        /// <returns>Byte array</returns>
        public static byte[] ReadAsBytes(Stream inputStream)
        {
            using (var ms = new MemoryStream())
            {
                inputStream.CopyTo(ms);
                return ms.ToArray();
            }
        }

        /// <summary>
        /// Select the Content-Type header's value from the given content-type array:
        /// if JSON type exists in the given array, use it;
        /// otherwise use the first one defined in 'consumes'
        /// </summary>
        /// <param name="contentTypes">The Content-Type array to select from.</param>
        /// <returns>The Content-Type header to use.</returns>
        public static string? SelectHeaderContentType(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
                return null;

            foreach (var contentType in contentTypes)
            {
                if (IsJsonMime(contentType))
                    return contentType;
            }

            return contentTypes[0]; // use the first content type specified in 'consumes'
        }

        /// <summary>
        /// Select the Accept header's value from the given accepts array:
        /// if JSON exists in the given array, use it;
        /// otherwise use all of them (joining into a string)
        /// </summary>
        /// <param name="accepts">The accepts array to select from.</param>
        /// <returns>The Accept header to use.</returns>
        public static string? SelectHeaderAccept(string[] accepts)
        {
            if (accepts.Length == 0)
                return null;

            if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
                return "application/json";

            return string.Join(",", accepts);
        }

        /// <summary>
        /// Provides a case-insensitive check that a provided content type is a known JSON-like content type.
        /// </summary>
        [GeneratedRegex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$")]
        private static partial Regex JsonRegex();

        /// <summary>
        /// Check if the given MIME is a JSON MIME.
        /// JSON MIME examples:
        ///    application/json
        ///    application/json; charset=UTF8
        ///    APPLICATION/JSON
        ///    application/vnd.company+json
        /// </summary>
        /// <param name="mime">MIME</param>
        /// <returns>Returns True if MIME type is json.</returns>
        public static bool IsJsonMime(string mime)
        {
            if (string.IsNullOrWhiteSpace(mime)) return false;

            return JsonRegex().IsMatch(mime) || mime.Equals("application/json-patch+json");
        }

        /// <summary>
        /// Get the discriminator
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="discriminator"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public static string? GetDiscriminator(Utf8JsonReader utf8JsonReader, string discriminator)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    if (localVarJsonPropertyName != null && localVarJsonPropertyName.Equals(discriminator))
                        return utf8JsonReader.GetString();
                }
            }

            throw new JsonException("The specified discriminator was not found.");
        }

        /// <summary>
        /// The base path of the API
        /// </summary>
        public const string BASE_ADDRESS = "https://api.weather.gov";

        /// <summary>
        /// The scheme of the API
        /// </summary>
        public const string SCHEME = "https";

        /// <summary>
        /// The context path of the API
        /// </summary>
        public const string CONTEXT_PATH = "";

        /// <summary>
        /// The host of the API
        /// </summary>
        public const string HOST = "api.weather.gov";

        /// <summary>
        /// The format to use for DateTime serialization
        /// </summary>
        public const string ISO8601_DATETIME_FORMAT = "o";
    }
}
